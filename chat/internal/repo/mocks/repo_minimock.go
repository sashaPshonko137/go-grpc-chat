// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package mocks

//go:generate minimock -i chat/internal/repo.repo -o repo_minimock.go -n RepoMock -p mocks

import (
	chatModel "chat/internal/model/chat"
	messageModel "chat/internal/model/message"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RepoMock implements repo.repo
type RepoMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateChat          func(name string) (i1 int32, err error)
	inspectFuncCreateChat   func(name string)
	afterCreateChatCounter  uint64
	beforeCreateChatCounter uint64
	CreateChatMock          mRepoMockCreateChat

	funcCreateChatUser          func(chat_id int32, user_id int32) (err error)
	inspectFuncCreateChatUser   func(chat_id int32, user_id int32)
	afterCreateChatUserCounter  uint64
	beforeCreateChatUserCounter uint64
	CreateChatUserMock          mRepoMockCreateChatUser

	funcCreateMessage          func(user_id int32, chat_id int32, content string, created_at time.Time) (err error)
	inspectFuncCreateMessage   func(user_id int32, chat_id int32, content string, created_at time.Time)
	afterCreateMessageCounter  uint64
	beforeCreateMessageCounter uint64
	CreateMessageMock          mRepoMockCreateMessage

	funcGetChat          func(chat_id int32) (cp1 *chatModel.Chat, err error)
	inspectFuncGetChat   func(chat_id int32)
	afterGetChatCounter  uint64
	beforeGetChatCounter uint64
	GetChatMock          mRepoMockGetChat

	funcGetMessagesFromChat          func(chatId int32) (mpa1 []*messageModel.Message, err error)
	inspectFuncGetMessagesFromChat   func(chatId int32)
	afterGetMessagesFromChatCounter  uint64
	beforeGetMessagesFromChatCounter uint64
	GetMessagesFromChatMock          mRepoMockGetMessagesFromChat
}

// NewRepoMock returns a mock for repo.repo
func NewRepoMock(t minimock.Tester) *RepoMock {
	m := &RepoMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateChatMock = mRepoMockCreateChat{mock: m}
	m.CreateChatMock.callArgs = []*RepoMockCreateChatParams{}

	m.CreateChatUserMock = mRepoMockCreateChatUser{mock: m}
	m.CreateChatUserMock.callArgs = []*RepoMockCreateChatUserParams{}

	m.CreateMessageMock = mRepoMockCreateMessage{mock: m}
	m.CreateMessageMock.callArgs = []*RepoMockCreateMessageParams{}

	m.GetChatMock = mRepoMockGetChat{mock: m}
	m.GetChatMock.callArgs = []*RepoMockGetChatParams{}

	m.GetMessagesFromChatMock = mRepoMockGetMessagesFromChat{mock: m}
	m.GetMessagesFromChatMock.callArgs = []*RepoMockGetMessagesFromChatParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepoMockCreateChat struct {
	optional           bool
	mock               *RepoMock
	defaultExpectation *RepoMockCreateChatExpectation
	expectations       []*RepoMockCreateChatExpectation

	callArgs []*RepoMockCreateChatParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepoMockCreateChatExpectation specifies expectation struct of the repo.CreateChat
type RepoMockCreateChatExpectation struct {
	mock      *RepoMock
	params    *RepoMockCreateChatParams
	paramPtrs *RepoMockCreateChatParamPtrs
	results   *RepoMockCreateChatResults
	Counter   uint64
}

// RepoMockCreateChatParams contains parameters of the repo.CreateChat
type RepoMockCreateChatParams struct {
	name string
}

// RepoMockCreateChatParamPtrs contains pointers to parameters of the repo.CreateChat
type RepoMockCreateChatParamPtrs struct {
	name *string
}

// RepoMockCreateChatResults contains results of the repo.CreateChat
type RepoMockCreateChatResults struct {
	i1  int32
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateChat *mRepoMockCreateChat) Optional() *mRepoMockCreateChat {
	mmCreateChat.optional = true
	return mmCreateChat
}

// Expect sets up expected params for repo.CreateChat
func (mmCreateChat *mRepoMockCreateChat) Expect(name string) *mRepoMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("RepoMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &RepoMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.paramPtrs != nil {
		mmCreateChat.mock.t.Fatalf("RepoMock.CreateChat mock is already set by ExpectParams functions")
	}

	mmCreateChat.defaultExpectation.params = &RepoMockCreateChatParams{name}
	for _, e := range mmCreateChat.expectations {
		if minimock.Equal(e.params, mmCreateChat.defaultExpectation.params) {
			mmCreateChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChat.defaultExpectation.params)
		}
	}

	return mmCreateChat
}

// ExpectNameParam1 sets up expected param name for repo.CreateChat
func (mmCreateChat *mRepoMockCreateChat) ExpectNameParam1(name string) *mRepoMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("RepoMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &RepoMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.params != nil {
		mmCreateChat.mock.t.Fatalf("RepoMock.CreateChat mock is already set by Expect")
	}

	if mmCreateChat.defaultExpectation.paramPtrs == nil {
		mmCreateChat.defaultExpectation.paramPtrs = &RepoMockCreateChatParamPtrs{}
	}
	mmCreateChat.defaultExpectation.paramPtrs.name = &name

	return mmCreateChat
}

// Inspect accepts an inspector function that has same arguments as the repo.CreateChat
func (mmCreateChat *mRepoMockCreateChat) Inspect(f func(name string)) *mRepoMockCreateChat {
	if mmCreateChat.mock.inspectFuncCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("Inspect function is already set for RepoMock.CreateChat")
	}

	mmCreateChat.mock.inspectFuncCreateChat = f

	return mmCreateChat
}

// Return sets up results that will be returned by repo.CreateChat
func (mmCreateChat *mRepoMockCreateChat) Return(i1 int32, err error) *RepoMock {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("RepoMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &RepoMockCreateChatExpectation{mock: mmCreateChat.mock}
	}
	mmCreateChat.defaultExpectation.results = &RepoMockCreateChatResults{i1, err}
	return mmCreateChat.mock
}

// Set uses given function f to mock the repo.CreateChat method
func (mmCreateChat *mRepoMockCreateChat) Set(f func(name string) (i1 int32, err error)) *RepoMock {
	if mmCreateChat.defaultExpectation != nil {
		mmCreateChat.mock.t.Fatalf("Default expectation is already set for the repo.CreateChat method")
	}

	if len(mmCreateChat.expectations) > 0 {
		mmCreateChat.mock.t.Fatalf("Some expectations are already set for the repo.CreateChat method")
	}

	mmCreateChat.mock.funcCreateChat = f
	return mmCreateChat.mock
}

// When sets expectation for the repo.CreateChat which will trigger the result defined by the following
// Then helper
func (mmCreateChat *mRepoMockCreateChat) When(name string) *RepoMockCreateChatExpectation {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("RepoMock.CreateChat mock is already set by Set")
	}

	expectation := &RepoMockCreateChatExpectation{
		mock:   mmCreateChat.mock,
		params: &RepoMockCreateChatParams{name},
	}
	mmCreateChat.expectations = append(mmCreateChat.expectations, expectation)
	return expectation
}

// Then sets up repo.CreateChat return parameters for the expectation previously defined by the When method
func (e *RepoMockCreateChatExpectation) Then(i1 int32, err error) *RepoMock {
	e.results = &RepoMockCreateChatResults{i1, err}
	return e.mock
}

// Times sets number of times repo.CreateChat should be invoked
func (mmCreateChat *mRepoMockCreateChat) Times(n uint64) *mRepoMockCreateChat {
	if n == 0 {
		mmCreateChat.mock.t.Fatalf("Times of RepoMock.CreateChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateChat.expectedInvocations, n)
	return mmCreateChat
}

func (mmCreateChat *mRepoMockCreateChat) invocationsDone() bool {
	if len(mmCreateChat.expectations) == 0 && mmCreateChat.defaultExpectation == nil && mmCreateChat.mock.funcCreateChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateChat.mock.afterCreateChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateChat implements repo.repo
func (mmCreateChat *RepoMock) CreateChat(name string) (i1 int32, err error) {
	mm_atomic.AddUint64(&mmCreateChat.beforeCreateChatCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateChat.afterCreateChatCounter, 1)

	if mmCreateChat.inspectFuncCreateChat != nil {
		mmCreateChat.inspectFuncCreateChat(name)
	}

	mm_params := RepoMockCreateChatParams{name}

	// Record call args
	mmCreateChat.CreateChatMock.mutex.Lock()
	mmCreateChat.CreateChatMock.callArgs = append(mmCreateChat.CreateChatMock.callArgs, &mm_params)
	mmCreateChat.CreateChatMock.mutex.Unlock()

	for _, e := range mmCreateChat.CreateChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateChat.CreateChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateChat.CreateChatMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateChat.CreateChatMock.defaultExpectation.params
		mm_want_ptrs := mmCreateChat.CreateChatMock.defaultExpectation.paramPtrs

		mm_got := RepoMockCreateChatParams{name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmCreateChat.t.Errorf("RepoMock.CreateChat got unexpected parameter name, want: %#v, got: %#v%s\n", *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateChat.t.Errorf("RepoMock.CreateChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateChat.CreateChatMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateChat.t.Fatal("No results are set for the RepoMock.CreateChat")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateChat.funcCreateChat != nil {
		return mmCreateChat.funcCreateChat(name)
	}
	mmCreateChat.t.Fatalf("Unexpected call to RepoMock.CreateChat. %v", name)
	return
}

// CreateChatAfterCounter returns a count of finished RepoMock.CreateChat invocations
func (mmCreateChat *RepoMock) CreateChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.afterCreateChatCounter)
}

// CreateChatBeforeCounter returns a count of RepoMock.CreateChat invocations
func (mmCreateChat *RepoMock) CreateChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.beforeCreateChatCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.CreateChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChat *mRepoMockCreateChat) Calls() []*RepoMockCreateChatParams {
	mmCreateChat.mutex.RLock()

	argCopy := make([]*RepoMockCreateChatParams, len(mmCreateChat.callArgs))
	copy(argCopy, mmCreateChat.callArgs)

	mmCreateChat.mutex.RUnlock()

	return argCopy
}

// MinimockCreateChatDone returns true if the count of the CreateChat invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockCreateChatDone() bool {
	if m.CreateChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateChatMock.invocationsDone()
}

// MinimockCreateChatInspect logs each unmet expectation
func (m *RepoMock) MinimockCreateChatInspect() {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.CreateChat with params: %#v", *e.params)
		}
	}

	afterCreateChatCounter := mm_atomic.LoadUint64(&m.afterCreateChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && afterCreateChatCounter < 1 {
		if m.CreateChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.CreateChat")
		} else {
			m.t.Errorf("Expected call to RepoMock.CreateChat with params: %#v", *m.CreateChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && afterCreateChatCounter < 1 {
		m.t.Error("Expected call to RepoMock.CreateChat")
	}

	if !m.CreateChatMock.invocationsDone() && afterCreateChatCounter > 0 {
		m.t.Errorf("Expected %d calls to RepoMock.CreateChat but found %d calls",
			mm_atomic.LoadUint64(&m.CreateChatMock.expectedInvocations), afterCreateChatCounter)
	}
}

type mRepoMockCreateChatUser struct {
	optional           bool
	mock               *RepoMock
	defaultExpectation *RepoMockCreateChatUserExpectation
	expectations       []*RepoMockCreateChatUserExpectation

	callArgs []*RepoMockCreateChatUserParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepoMockCreateChatUserExpectation specifies expectation struct of the repo.CreateChatUser
type RepoMockCreateChatUserExpectation struct {
	mock      *RepoMock
	params    *RepoMockCreateChatUserParams
	paramPtrs *RepoMockCreateChatUserParamPtrs
	results   *RepoMockCreateChatUserResults
	Counter   uint64
}

// RepoMockCreateChatUserParams contains parameters of the repo.CreateChatUser
type RepoMockCreateChatUserParams struct {
	chat_id int32
	user_id int32
}

// RepoMockCreateChatUserParamPtrs contains pointers to parameters of the repo.CreateChatUser
type RepoMockCreateChatUserParamPtrs struct {
	chat_id *int32
	user_id *int32
}

// RepoMockCreateChatUserResults contains results of the repo.CreateChatUser
type RepoMockCreateChatUserResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateChatUser *mRepoMockCreateChatUser) Optional() *mRepoMockCreateChatUser {
	mmCreateChatUser.optional = true
	return mmCreateChatUser
}

// Expect sets up expected params for repo.CreateChatUser
func (mmCreateChatUser *mRepoMockCreateChatUser) Expect(chat_id int32, user_id int32) *mRepoMockCreateChatUser {
	if mmCreateChatUser.mock.funcCreateChatUser != nil {
		mmCreateChatUser.mock.t.Fatalf("RepoMock.CreateChatUser mock is already set by Set")
	}

	if mmCreateChatUser.defaultExpectation == nil {
		mmCreateChatUser.defaultExpectation = &RepoMockCreateChatUserExpectation{}
	}

	if mmCreateChatUser.defaultExpectation.paramPtrs != nil {
		mmCreateChatUser.mock.t.Fatalf("RepoMock.CreateChatUser mock is already set by ExpectParams functions")
	}

	mmCreateChatUser.defaultExpectation.params = &RepoMockCreateChatUserParams{chat_id, user_id}
	for _, e := range mmCreateChatUser.expectations {
		if minimock.Equal(e.params, mmCreateChatUser.defaultExpectation.params) {
			mmCreateChatUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChatUser.defaultExpectation.params)
		}
	}

	return mmCreateChatUser
}

// ExpectChat_idParam1 sets up expected param chat_id for repo.CreateChatUser
func (mmCreateChatUser *mRepoMockCreateChatUser) ExpectChat_idParam1(chat_id int32) *mRepoMockCreateChatUser {
	if mmCreateChatUser.mock.funcCreateChatUser != nil {
		mmCreateChatUser.mock.t.Fatalf("RepoMock.CreateChatUser mock is already set by Set")
	}

	if mmCreateChatUser.defaultExpectation == nil {
		mmCreateChatUser.defaultExpectation = &RepoMockCreateChatUserExpectation{}
	}

	if mmCreateChatUser.defaultExpectation.params != nil {
		mmCreateChatUser.mock.t.Fatalf("RepoMock.CreateChatUser mock is already set by Expect")
	}

	if mmCreateChatUser.defaultExpectation.paramPtrs == nil {
		mmCreateChatUser.defaultExpectation.paramPtrs = &RepoMockCreateChatUserParamPtrs{}
	}
	mmCreateChatUser.defaultExpectation.paramPtrs.chat_id = &chat_id

	return mmCreateChatUser
}

// ExpectUser_idParam2 sets up expected param user_id for repo.CreateChatUser
func (mmCreateChatUser *mRepoMockCreateChatUser) ExpectUser_idParam2(user_id int32) *mRepoMockCreateChatUser {
	if mmCreateChatUser.mock.funcCreateChatUser != nil {
		mmCreateChatUser.mock.t.Fatalf("RepoMock.CreateChatUser mock is already set by Set")
	}

	if mmCreateChatUser.defaultExpectation == nil {
		mmCreateChatUser.defaultExpectation = &RepoMockCreateChatUserExpectation{}
	}

	if mmCreateChatUser.defaultExpectation.params != nil {
		mmCreateChatUser.mock.t.Fatalf("RepoMock.CreateChatUser mock is already set by Expect")
	}

	if mmCreateChatUser.defaultExpectation.paramPtrs == nil {
		mmCreateChatUser.defaultExpectation.paramPtrs = &RepoMockCreateChatUserParamPtrs{}
	}
	mmCreateChatUser.defaultExpectation.paramPtrs.user_id = &user_id

	return mmCreateChatUser
}

// Inspect accepts an inspector function that has same arguments as the repo.CreateChatUser
func (mmCreateChatUser *mRepoMockCreateChatUser) Inspect(f func(chat_id int32, user_id int32)) *mRepoMockCreateChatUser {
	if mmCreateChatUser.mock.inspectFuncCreateChatUser != nil {
		mmCreateChatUser.mock.t.Fatalf("Inspect function is already set for RepoMock.CreateChatUser")
	}

	mmCreateChatUser.mock.inspectFuncCreateChatUser = f

	return mmCreateChatUser
}

// Return sets up results that will be returned by repo.CreateChatUser
func (mmCreateChatUser *mRepoMockCreateChatUser) Return(err error) *RepoMock {
	if mmCreateChatUser.mock.funcCreateChatUser != nil {
		mmCreateChatUser.mock.t.Fatalf("RepoMock.CreateChatUser mock is already set by Set")
	}

	if mmCreateChatUser.defaultExpectation == nil {
		mmCreateChatUser.defaultExpectation = &RepoMockCreateChatUserExpectation{mock: mmCreateChatUser.mock}
	}
	mmCreateChatUser.defaultExpectation.results = &RepoMockCreateChatUserResults{err}
	return mmCreateChatUser.mock
}

// Set uses given function f to mock the repo.CreateChatUser method
func (mmCreateChatUser *mRepoMockCreateChatUser) Set(f func(chat_id int32, user_id int32) (err error)) *RepoMock {
	if mmCreateChatUser.defaultExpectation != nil {
		mmCreateChatUser.mock.t.Fatalf("Default expectation is already set for the repo.CreateChatUser method")
	}

	if len(mmCreateChatUser.expectations) > 0 {
		mmCreateChatUser.mock.t.Fatalf("Some expectations are already set for the repo.CreateChatUser method")
	}

	mmCreateChatUser.mock.funcCreateChatUser = f
	return mmCreateChatUser.mock
}

// When sets expectation for the repo.CreateChatUser which will trigger the result defined by the following
// Then helper
func (mmCreateChatUser *mRepoMockCreateChatUser) When(chat_id int32, user_id int32) *RepoMockCreateChatUserExpectation {
	if mmCreateChatUser.mock.funcCreateChatUser != nil {
		mmCreateChatUser.mock.t.Fatalf("RepoMock.CreateChatUser mock is already set by Set")
	}

	expectation := &RepoMockCreateChatUserExpectation{
		mock:   mmCreateChatUser.mock,
		params: &RepoMockCreateChatUserParams{chat_id, user_id},
	}
	mmCreateChatUser.expectations = append(mmCreateChatUser.expectations, expectation)
	return expectation
}

// Then sets up repo.CreateChatUser return parameters for the expectation previously defined by the When method
func (e *RepoMockCreateChatUserExpectation) Then(err error) *RepoMock {
	e.results = &RepoMockCreateChatUserResults{err}
	return e.mock
}

// Times sets number of times repo.CreateChatUser should be invoked
func (mmCreateChatUser *mRepoMockCreateChatUser) Times(n uint64) *mRepoMockCreateChatUser {
	if n == 0 {
		mmCreateChatUser.mock.t.Fatalf("Times of RepoMock.CreateChatUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateChatUser.expectedInvocations, n)
	return mmCreateChatUser
}

func (mmCreateChatUser *mRepoMockCreateChatUser) invocationsDone() bool {
	if len(mmCreateChatUser.expectations) == 0 && mmCreateChatUser.defaultExpectation == nil && mmCreateChatUser.mock.funcCreateChatUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateChatUser.mock.afterCreateChatUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateChatUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateChatUser implements repo.repo
func (mmCreateChatUser *RepoMock) CreateChatUser(chat_id int32, user_id int32) (err error) {
	mm_atomic.AddUint64(&mmCreateChatUser.beforeCreateChatUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateChatUser.afterCreateChatUserCounter, 1)

	if mmCreateChatUser.inspectFuncCreateChatUser != nil {
		mmCreateChatUser.inspectFuncCreateChatUser(chat_id, user_id)
	}

	mm_params := RepoMockCreateChatUserParams{chat_id, user_id}

	// Record call args
	mmCreateChatUser.CreateChatUserMock.mutex.Lock()
	mmCreateChatUser.CreateChatUserMock.callArgs = append(mmCreateChatUser.CreateChatUserMock.callArgs, &mm_params)
	mmCreateChatUser.CreateChatUserMock.mutex.Unlock()

	for _, e := range mmCreateChatUser.CreateChatUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateChatUser.CreateChatUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateChatUser.CreateChatUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateChatUser.CreateChatUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateChatUser.CreateChatUserMock.defaultExpectation.paramPtrs

		mm_got := RepoMockCreateChatUserParams{chat_id, user_id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.chat_id != nil && !minimock.Equal(*mm_want_ptrs.chat_id, mm_got.chat_id) {
				mmCreateChatUser.t.Errorf("RepoMock.CreateChatUser got unexpected parameter chat_id, want: %#v, got: %#v%s\n", *mm_want_ptrs.chat_id, mm_got.chat_id, minimock.Diff(*mm_want_ptrs.chat_id, mm_got.chat_id))
			}

			if mm_want_ptrs.user_id != nil && !minimock.Equal(*mm_want_ptrs.user_id, mm_got.user_id) {
				mmCreateChatUser.t.Errorf("RepoMock.CreateChatUser got unexpected parameter user_id, want: %#v, got: %#v%s\n", *mm_want_ptrs.user_id, mm_got.user_id, minimock.Diff(*mm_want_ptrs.user_id, mm_got.user_id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateChatUser.t.Errorf("RepoMock.CreateChatUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateChatUser.CreateChatUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateChatUser.t.Fatal("No results are set for the RepoMock.CreateChatUser")
		}
		return (*mm_results).err
	}
	if mmCreateChatUser.funcCreateChatUser != nil {
		return mmCreateChatUser.funcCreateChatUser(chat_id, user_id)
	}
	mmCreateChatUser.t.Fatalf("Unexpected call to RepoMock.CreateChatUser. %v %v", chat_id, user_id)
	return
}

// CreateChatUserAfterCounter returns a count of finished RepoMock.CreateChatUser invocations
func (mmCreateChatUser *RepoMock) CreateChatUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChatUser.afterCreateChatUserCounter)
}

// CreateChatUserBeforeCounter returns a count of RepoMock.CreateChatUser invocations
func (mmCreateChatUser *RepoMock) CreateChatUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChatUser.beforeCreateChatUserCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.CreateChatUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChatUser *mRepoMockCreateChatUser) Calls() []*RepoMockCreateChatUserParams {
	mmCreateChatUser.mutex.RLock()

	argCopy := make([]*RepoMockCreateChatUserParams, len(mmCreateChatUser.callArgs))
	copy(argCopy, mmCreateChatUser.callArgs)

	mmCreateChatUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateChatUserDone returns true if the count of the CreateChatUser invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockCreateChatUserDone() bool {
	if m.CreateChatUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateChatUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateChatUserMock.invocationsDone()
}

// MinimockCreateChatUserInspect logs each unmet expectation
func (m *RepoMock) MinimockCreateChatUserInspect() {
	for _, e := range m.CreateChatUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.CreateChatUser with params: %#v", *e.params)
		}
	}

	afterCreateChatUserCounter := mm_atomic.LoadUint64(&m.afterCreateChatUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatUserMock.defaultExpectation != nil && afterCreateChatUserCounter < 1 {
		if m.CreateChatUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.CreateChatUser")
		} else {
			m.t.Errorf("Expected call to RepoMock.CreateChatUser with params: %#v", *m.CreateChatUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChatUser != nil && afterCreateChatUserCounter < 1 {
		m.t.Error("Expected call to RepoMock.CreateChatUser")
	}

	if !m.CreateChatUserMock.invocationsDone() && afterCreateChatUserCounter > 0 {
		m.t.Errorf("Expected %d calls to RepoMock.CreateChatUser but found %d calls",
			mm_atomic.LoadUint64(&m.CreateChatUserMock.expectedInvocations), afterCreateChatUserCounter)
	}
}

type mRepoMockCreateMessage struct {
	optional           bool
	mock               *RepoMock
	defaultExpectation *RepoMockCreateMessageExpectation
	expectations       []*RepoMockCreateMessageExpectation

	callArgs []*RepoMockCreateMessageParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepoMockCreateMessageExpectation specifies expectation struct of the repo.CreateMessage
type RepoMockCreateMessageExpectation struct {
	mock      *RepoMock
	params    *RepoMockCreateMessageParams
	paramPtrs *RepoMockCreateMessageParamPtrs
	results   *RepoMockCreateMessageResults
	Counter   uint64
}

// RepoMockCreateMessageParams contains parameters of the repo.CreateMessage
type RepoMockCreateMessageParams struct {
	user_id    int32
	chat_id    int32
	content    string
	created_at time.Time
}

// RepoMockCreateMessageParamPtrs contains pointers to parameters of the repo.CreateMessage
type RepoMockCreateMessageParamPtrs struct {
	user_id    *int32
	chat_id    *int32
	content    *string
	created_at *time.Time
}

// RepoMockCreateMessageResults contains results of the repo.CreateMessage
type RepoMockCreateMessageResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateMessage *mRepoMockCreateMessage) Optional() *mRepoMockCreateMessage {
	mmCreateMessage.optional = true
	return mmCreateMessage
}

// Expect sets up expected params for repo.CreateMessage
func (mmCreateMessage *mRepoMockCreateMessage) Expect(user_id int32, chat_id int32, content string, created_at time.Time) *mRepoMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("RepoMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &RepoMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.paramPtrs != nil {
		mmCreateMessage.mock.t.Fatalf("RepoMock.CreateMessage mock is already set by ExpectParams functions")
	}

	mmCreateMessage.defaultExpectation.params = &RepoMockCreateMessageParams{user_id, chat_id, content, created_at}
	for _, e := range mmCreateMessage.expectations {
		if minimock.Equal(e.params, mmCreateMessage.defaultExpectation.params) {
			mmCreateMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateMessage.defaultExpectation.params)
		}
	}

	return mmCreateMessage
}

// ExpectUser_idParam1 sets up expected param user_id for repo.CreateMessage
func (mmCreateMessage *mRepoMockCreateMessage) ExpectUser_idParam1(user_id int32) *mRepoMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("RepoMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &RepoMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.params != nil {
		mmCreateMessage.mock.t.Fatalf("RepoMock.CreateMessage mock is already set by Expect")
	}

	if mmCreateMessage.defaultExpectation.paramPtrs == nil {
		mmCreateMessage.defaultExpectation.paramPtrs = &RepoMockCreateMessageParamPtrs{}
	}
	mmCreateMessage.defaultExpectation.paramPtrs.user_id = &user_id

	return mmCreateMessage
}

// ExpectChat_idParam2 sets up expected param chat_id for repo.CreateMessage
func (mmCreateMessage *mRepoMockCreateMessage) ExpectChat_idParam2(chat_id int32) *mRepoMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("RepoMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &RepoMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.params != nil {
		mmCreateMessage.mock.t.Fatalf("RepoMock.CreateMessage mock is already set by Expect")
	}

	if mmCreateMessage.defaultExpectation.paramPtrs == nil {
		mmCreateMessage.defaultExpectation.paramPtrs = &RepoMockCreateMessageParamPtrs{}
	}
	mmCreateMessage.defaultExpectation.paramPtrs.chat_id = &chat_id

	return mmCreateMessage
}

// ExpectContentParam3 sets up expected param content for repo.CreateMessage
func (mmCreateMessage *mRepoMockCreateMessage) ExpectContentParam3(content string) *mRepoMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("RepoMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &RepoMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.params != nil {
		mmCreateMessage.mock.t.Fatalf("RepoMock.CreateMessage mock is already set by Expect")
	}

	if mmCreateMessage.defaultExpectation.paramPtrs == nil {
		mmCreateMessage.defaultExpectation.paramPtrs = &RepoMockCreateMessageParamPtrs{}
	}
	mmCreateMessage.defaultExpectation.paramPtrs.content = &content

	return mmCreateMessage
}

// ExpectCreated_atParam4 sets up expected param created_at for repo.CreateMessage
func (mmCreateMessage *mRepoMockCreateMessage) ExpectCreated_atParam4(created_at time.Time) *mRepoMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("RepoMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &RepoMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.params != nil {
		mmCreateMessage.mock.t.Fatalf("RepoMock.CreateMessage mock is already set by Expect")
	}

	if mmCreateMessage.defaultExpectation.paramPtrs == nil {
		mmCreateMessage.defaultExpectation.paramPtrs = &RepoMockCreateMessageParamPtrs{}
	}
	mmCreateMessage.defaultExpectation.paramPtrs.created_at = &created_at

	return mmCreateMessage
}

// Inspect accepts an inspector function that has same arguments as the repo.CreateMessage
func (mmCreateMessage *mRepoMockCreateMessage) Inspect(f func(user_id int32, chat_id int32, content string, created_at time.Time)) *mRepoMockCreateMessage {
	if mmCreateMessage.mock.inspectFuncCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("Inspect function is already set for RepoMock.CreateMessage")
	}

	mmCreateMessage.mock.inspectFuncCreateMessage = f

	return mmCreateMessage
}

// Return sets up results that will be returned by repo.CreateMessage
func (mmCreateMessage *mRepoMockCreateMessage) Return(err error) *RepoMock {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("RepoMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &RepoMockCreateMessageExpectation{mock: mmCreateMessage.mock}
	}
	mmCreateMessage.defaultExpectation.results = &RepoMockCreateMessageResults{err}
	return mmCreateMessage.mock
}

// Set uses given function f to mock the repo.CreateMessage method
func (mmCreateMessage *mRepoMockCreateMessage) Set(f func(user_id int32, chat_id int32, content string, created_at time.Time) (err error)) *RepoMock {
	if mmCreateMessage.defaultExpectation != nil {
		mmCreateMessage.mock.t.Fatalf("Default expectation is already set for the repo.CreateMessage method")
	}

	if len(mmCreateMessage.expectations) > 0 {
		mmCreateMessage.mock.t.Fatalf("Some expectations are already set for the repo.CreateMessage method")
	}

	mmCreateMessage.mock.funcCreateMessage = f
	return mmCreateMessage.mock
}

// When sets expectation for the repo.CreateMessage which will trigger the result defined by the following
// Then helper
func (mmCreateMessage *mRepoMockCreateMessage) When(user_id int32, chat_id int32, content string, created_at time.Time) *RepoMockCreateMessageExpectation {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("RepoMock.CreateMessage mock is already set by Set")
	}

	expectation := &RepoMockCreateMessageExpectation{
		mock:   mmCreateMessage.mock,
		params: &RepoMockCreateMessageParams{user_id, chat_id, content, created_at},
	}
	mmCreateMessage.expectations = append(mmCreateMessage.expectations, expectation)
	return expectation
}

// Then sets up repo.CreateMessage return parameters for the expectation previously defined by the When method
func (e *RepoMockCreateMessageExpectation) Then(err error) *RepoMock {
	e.results = &RepoMockCreateMessageResults{err}
	return e.mock
}

// Times sets number of times repo.CreateMessage should be invoked
func (mmCreateMessage *mRepoMockCreateMessage) Times(n uint64) *mRepoMockCreateMessage {
	if n == 0 {
		mmCreateMessage.mock.t.Fatalf("Times of RepoMock.CreateMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateMessage.expectedInvocations, n)
	return mmCreateMessage
}

func (mmCreateMessage *mRepoMockCreateMessage) invocationsDone() bool {
	if len(mmCreateMessage.expectations) == 0 && mmCreateMessage.defaultExpectation == nil && mmCreateMessage.mock.funcCreateMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateMessage.mock.afterCreateMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateMessage implements repo.repo
func (mmCreateMessage *RepoMock) CreateMessage(user_id int32, chat_id int32, content string, created_at time.Time) (err error) {
	mm_atomic.AddUint64(&mmCreateMessage.beforeCreateMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateMessage.afterCreateMessageCounter, 1)

	if mmCreateMessage.inspectFuncCreateMessage != nil {
		mmCreateMessage.inspectFuncCreateMessage(user_id, chat_id, content, created_at)
	}

	mm_params := RepoMockCreateMessageParams{user_id, chat_id, content, created_at}

	// Record call args
	mmCreateMessage.CreateMessageMock.mutex.Lock()
	mmCreateMessage.CreateMessageMock.callArgs = append(mmCreateMessage.CreateMessageMock.callArgs, &mm_params)
	mmCreateMessage.CreateMessageMock.mutex.Unlock()

	for _, e := range mmCreateMessage.CreateMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateMessage.CreateMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateMessage.CreateMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateMessage.CreateMessageMock.defaultExpectation.params
		mm_want_ptrs := mmCreateMessage.CreateMessageMock.defaultExpectation.paramPtrs

		mm_got := RepoMockCreateMessageParams{user_id, chat_id, content, created_at}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.user_id != nil && !minimock.Equal(*mm_want_ptrs.user_id, mm_got.user_id) {
				mmCreateMessage.t.Errorf("RepoMock.CreateMessage got unexpected parameter user_id, want: %#v, got: %#v%s\n", *mm_want_ptrs.user_id, mm_got.user_id, minimock.Diff(*mm_want_ptrs.user_id, mm_got.user_id))
			}

			if mm_want_ptrs.chat_id != nil && !minimock.Equal(*mm_want_ptrs.chat_id, mm_got.chat_id) {
				mmCreateMessage.t.Errorf("RepoMock.CreateMessage got unexpected parameter chat_id, want: %#v, got: %#v%s\n", *mm_want_ptrs.chat_id, mm_got.chat_id, minimock.Diff(*mm_want_ptrs.chat_id, mm_got.chat_id))
			}

			if mm_want_ptrs.content != nil && !minimock.Equal(*mm_want_ptrs.content, mm_got.content) {
				mmCreateMessage.t.Errorf("RepoMock.CreateMessage got unexpected parameter content, want: %#v, got: %#v%s\n", *mm_want_ptrs.content, mm_got.content, minimock.Diff(*mm_want_ptrs.content, mm_got.content))
			}

			if mm_want_ptrs.created_at != nil && !minimock.Equal(*mm_want_ptrs.created_at, mm_got.created_at) {
				mmCreateMessage.t.Errorf("RepoMock.CreateMessage got unexpected parameter created_at, want: %#v, got: %#v%s\n", *mm_want_ptrs.created_at, mm_got.created_at, minimock.Diff(*mm_want_ptrs.created_at, mm_got.created_at))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateMessage.t.Errorf("RepoMock.CreateMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateMessage.CreateMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateMessage.t.Fatal("No results are set for the RepoMock.CreateMessage")
		}
		return (*mm_results).err
	}
	if mmCreateMessage.funcCreateMessage != nil {
		return mmCreateMessage.funcCreateMessage(user_id, chat_id, content, created_at)
	}
	mmCreateMessage.t.Fatalf("Unexpected call to RepoMock.CreateMessage. %v %v %v %v", user_id, chat_id, content, created_at)
	return
}

// CreateMessageAfterCounter returns a count of finished RepoMock.CreateMessage invocations
func (mmCreateMessage *RepoMock) CreateMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateMessage.afterCreateMessageCounter)
}

// CreateMessageBeforeCounter returns a count of RepoMock.CreateMessage invocations
func (mmCreateMessage *RepoMock) CreateMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateMessage.beforeCreateMessageCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.CreateMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateMessage *mRepoMockCreateMessage) Calls() []*RepoMockCreateMessageParams {
	mmCreateMessage.mutex.RLock()

	argCopy := make([]*RepoMockCreateMessageParams, len(mmCreateMessage.callArgs))
	copy(argCopy, mmCreateMessage.callArgs)

	mmCreateMessage.mutex.RUnlock()

	return argCopy
}

// MinimockCreateMessageDone returns true if the count of the CreateMessage invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockCreateMessageDone() bool {
	if m.CreateMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMessageMock.invocationsDone()
}

// MinimockCreateMessageInspect logs each unmet expectation
func (m *RepoMock) MinimockCreateMessageInspect() {
	for _, e := range m.CreateMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.CreateMessage with params: %#v", *e.params)
		}
	}

	afterCreateMessageCounter := mm_atomic.LoadUint64(&m.afterCreateMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMessageMock.defaultExpectation != nil && afterCreateMessageCounter < 1 {
		if m.CreateMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.CreateMessage")
		} else {
			m.t.Errorf("Expected call to RepoMock.CreateMessage with params: %#v", *m.CreateMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateMessage != nil && afterCreateMessageCounter < 1 {
		m.t.Error("Expected call to RepoMock.CreateMessage")
	}

	if !m.CreateMessageMock.invocationsDone() && afterCreateMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to RepoMock.CreateMessage but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMessageMock.expectedInvocations), afterCreateMessageCounter)
	}
}

type mRepoMockGetChat struct {
	optional           bool
	mock               *RepoMock
	defaultExpectation *RepoMockGetChatExpectation
	expectations       []*RepoMockGetChatExpectation

	callArgs []*RepoMockGetChatParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepoMockGetChatExpectation specifies expectation struct of the repo.GetChat
type RepoMockGetChatExpectation struct {
	mock      *RepoMock
	params    *RepoMockGetChatParams
	paramPtrs *RepoMockGetChatParamPtrs
	results   *RepoMockGetChatResults
	Counter   uint64
}

// RepoMockGetChatParams contains parameters of the repo.GetChat
type RepoMockGetChatParams struct {
	chat_id int32
}

// RepoMockGetChatParamPtrs contains pointers to parameters of the repo.GetChat
type RepoMockGetChatParamPtrs struct {
	chat_id *int32
}

// RepoMockGetChatResults contains results of the repo.GetChat
type RepoMockGetChatResults struct {
	cp1 *chatModel.Chat
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetChat *mRepoMockGetChat) Optional() *mRepoMockGetChat {
	mmGetChat.optional = true
	return mmGetChat
}

// Expect sets up expected params for repo.GetChat
func (mmGetChat *mRepoMockGetChat) Expect(chat_id int32) *mRepoMockGetChat {
	if mmGetChat.mock.funcGetChat != nil {
		mmGetChat.mock.t.Fatalf("RepoMock.GetChat mock is already set by Set")
	}

	if mmGetChat.defaultExpectation == nil {
		mmGetChat.defaultExpectation = &RepoMockGetChatExpectation{}
	}

	if mmGetChat.defaultExpectation.paramPtrs != nil {
		mmGetChat.mock.t.Fatalf("RepoMock.GetChat mock is already set by ExpectParams functions")
	}

	mmGetChat.defaultExpectation.params = &RepoMockGetChatParams{chat_id}
	for _, e := range mmGetChat.expectations {
		if minimock.Equal(e.params, mmGetChat.defaultExpectation.params) {
			mmGetChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChat.defaultExpectation.params)
		}
	}

	return mmGetChat
}

// ExpectChat_idParam1 sets up expected param chat_id for repo.GetChat
func (mmGetChat *mRepoMockGetChat) ExpectChat_idParam1(chat_id int32) *mRepoMockGetChat {
	if mmGetChat.mock.funcGetChat != nil {
		mmGetChat.mock.t.Fatalf("RepoMock.GetChat mock is already set by Set")
	}

	if mmGetChat.defaultExpectation == nil {
		mmGetChat.defaultExpectation = &RepoMockGetChatExpectation{}
	}

	if mmGetChat.defaultExpectation.params != nil {
		mmGetChat.mock.t.Fatalf("RepoMock.GetChat mock is already set by Expect")
	}

	if mmGetChat.defaultExpectation.paramPtrs == nil {
		mmGetChat.defaultExpectation.paramPtrs = &RepoMockGetChatParamPtrs{}
	}
	mmGetChat.defaultExpectation.paramPtrs.chat_id = &chat_id

	return mmGetChat
}

// Inspect accepts an inspector function that has same arguments as the repo.GetChat
func (mmGetChat *mRepoMockGetChat) Inspect(f func(chat_id int32)) *mRepoMockGetChat {
	if mmGetChat.mock.inspectFuncGetChat != nil {
		mmGetChat.mock.t.Fatalf("Inspect function is already set for RepoMock.GetChat")
	}

	mmGetChat.mock.inspectFuncGetChat = f

	return mmGetChat
}

// Return sets up results that will be returned by repo.GetChat
func (mmGetChat *mRepoMockGetChat) Return(cp1 *chatModel.Chat, err error) *RepoMock {
	if mmGetChat.mock.funcGetChat != nil {
		mmGetChat.mock.t.Fatalf("RepoMock.GetChat mock is already set by Set")
	}

	if mmGetChat.defaultExpectation == nil {
		mmGetChat.defaultExpectation = &RepoMockGetChatExpectation{mock: mmGetChat.mock}
	}
	mmGetChat.defaultExpectation.results = &RepoMockGetChatResults{cp1, err}
	return mmGetChat.mock
}

// Set uses given function f to mock the repo.GetChat method
func (mmGetChat *mRepoMockGetChat) Set(f func(chat_id int32) (cp1 *chatModel.Chat, err error)) *RepoMock {
	if mmGetChat.defaultExpectation != nil {
		mmGetChat.mock.t.Fatalf("Default expectation is already set for the repo.GetChat method")
	}

	if len(mmGetChat.expectations) > 0 {
		mmGetChat.mock.t.Fatalf("Some expectations are already set for the repo.GetChat method")
	}

	mmGetChat.mock.funcGetChat = f
	return mmGetChat.mock
}

// When sets expectation for the repo.GetChat which will trigger the result defined by the following
// Then helper
func (mmGetChat *mRepoMockGetChat) When(chat_id int32) *RepoMockGetChatExpectation {
	if mmGetChat.mock.funcGetChat != nil {
		mmGetChat.mock.t.Fatalf("RepoMock.GetChat mock is already set by Set")
	}

	expectation := &RepoMockGetChatExpectation{
		mock:   mmGetChat.mock,
		params: &RepoMockGetChatParams{chat_id},
	}
	mmGetChat.expectations = append(mmGetChat.expectations, expectation)
	return expectation
}

// Then sets up repo.GetChat return parameters for the expectation previously defined by the When method
func (e *RepoMockGetChatExpectation) Then(cp1 *chatModel.Chat, err error) *RepoMock {
	e.results = &RepoMockGetChatResults{cp1, err}
	return e.mock
}

// Times sets number of times repo.GetChat should be invoked
func (mmGetChat *mRepoMockGetChat) Times(n uint64) *mRepoMockGetChat {
	if n == 0 {
		mmGetChat.mock.t.Fatalf("Times of RepoMock.GetChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetChat.expectedInvocations, n)
	return mmGetChat
}

func (mmGetChat *mRepoMockGetChat) invocationsDone() bool {
	if len(mmGetChat.expectations) == 0 && mmGetChat.defaultExpectation == nil && mmGetChat.mock.funcGetChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetChat.mock.afterGetChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetChat implements repo.repo
func (mmGetChat *RepoMock) GetChat(chat_id int32) (cp1 *chatModel.Chat, err error) {
	mm_atomic.AddUint64(&mmGetChat.beforeGetChatCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChat.afterGetChatCounter, 1)

	if mmGetChat.inspectFuncGetChat != nil {
		mmGetChat.inspectFuncGetChat(chat_id)
	}

	mm_params := RepoMockGetChatParams{chat_id}

	// Record call args
	mmGetChat.GetChatMock.mutex.Lock()
	mmGetChat.GetChatMock.callArgs = append(mmGetChat.GetChatMock.callArgs, &mm_params)
	mmGetChat.GetChatMock.mutex.Unlock()

	for _, e := range mmGetChat.GetChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetChat.GetChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChat.GetChatMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChat.GetChatMock.defaultExpectation.params
		mm_want_ptrs := mmGetChat.GetChatMock.defaultExpectation.paramPtrs

		mm_got := RepoMockGetChatParams{chat_id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.chat_id != nil && !minimock.Equal(*mm_want_ptrs.chat_id, mm_got.chat_id) {
				mmGetChat.t.Errorf("RepoMock.GetChat got unexpected parameter chat_id, want: %#v, got: %#v%s\n", *mm_want_ptrs.chat_id, mm_got.chat_id, minimock.Diff(*mm_want_ptrs.chat_id, mm_got.chat_id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChat.t.Errorf("RepoMock.GetChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChat.GetChatMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChat.t.Fatal("No results are set for the RepoMock.GetChat")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetChat.funcGetChat != nil {
		return mmGetChat.funcGetChat(chat_id)
	}
	mmGetChat.t.Fatalf("Unexpected call to RepoMock.GetChat. %v", chat_id)
	return
}

// GetChatAfterCounter returns a count of finished RepoMock.GetChat invocations
func (mmGetChat *RepoMock) GetChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChat.afterGetChatCounter)
}

// GetChatBeforeCounter returns a count of RepoMock.GetChat invocations
func (mmGetChat *RepoMock) GetChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChat.beforeGetChatCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.GetChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChat *mRepoMockGetChat) Calls() []*RepoMockGetChatParams {
	mmGetChat.mutex.RLock()

	argCopy := make([]*RepoMockGetChatParams, len(mmGetChat.callArgs))
	copy(argCopy, mmGetChat.callArgs)

	mmGetChat.mutex.RUnlock()

	return argCopy
}

// MinimockGetChatDone returns true if the count of the GetChat invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockGetChatDone() bool {
	if m.GetChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetChatMock.invocationsDone()
}

// MinimockGetChatInspect logs each unmet expectation
func (m *RepoMock) MinimockGetChatInspect() {
	for _, e := range m.GetChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.GetChat with params: %#v", *e.params)
		}
	}

	afterGetChatCounter := mm_atomic.LoadUint64(&m.afterGetChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatMock.defaultExpectation != nil && afterGetChatCounter < 1 {
		if m.GetChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.GetChat")
		} else {
			m.t.Errorf("Expected call to RepoMock.GetChat with params: %#v", *m.GetChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChat != nil && afterGetChatCounter < 1 {
		m.t.Error("Expected call to RepoMock.GetChat")
	}

	if !m.GetChatMock.invocationsDone() && afterGetChatCounter > 0 {
		m.t.Errorf("Expected %d calls to RepoMock.GetChat but found %d calls",
			mm_atomic.LoadUint64(&m.GetChatMock.expectedInvocations), afterGetChatCounter)
	}
}

type mRepoMockGetMessagesFromChat struct {
	optional           bool
	mock               *RepoMock
	defaultExpectation *RepoMockGetMessagesFromChatExpectation
	expectations       []*RepoMockGetMessagesFromChatExpectation

	callArgs []*RepoMockGetMessagesFromChatParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepoMockGetMessagesFromChatExpectation specifies expectation struct of the repo.GetMessagesFromChat
type RepoMockGetMessagesFromChatExpectation struct {
	mock      *RepoMock
	params    *RepoMockGetMessagesFromChatParams
	paramPtrs *RepoMockGetMessagesFromChatParamPtrs
	results   *RepoMockGetMessagesFromChatResults
	Counter   uint64
}

// RepoMockGetMessagesFromChatParams contains parameters of the repo.GetMessagesFromChat
type RepoMockGetMessagesFromChatParams struct {
	chatId int32
}

// RepoMockGetMessagesFromChatParamPtrs contains pointers to parameters of the repo.GetMessagesFromChat
type RepoMockGetMessagesFromChatParamPtrs struct {
	chatId *int32
}

// RepoMockGetMessagesFromChatResults contains results of the repo.GetMessagesFromChat
type RepoMockGetMessagesFromChatResults struct {
	mpa1 []*messageModel.Message
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetMessagesFromChat *mRepoMockGetMessagesFromChat) Optional() *mRepoMockGetMessagesFromChat {
	mmGetMessagesFromChat.optional = true
	return mmGetMessagesFromChat
}

// Expect sets up expected params for repo.GetMessagesFromChat
func (mmGetMessagesFromChat *mRepoMockGetMessagesFromChat) Expect(chatId int32) *mRepoMockGetMessagesFromChat {
	if mmGetMessagesFromChat.mock.funcGetMessagesFromChat != nil {
		mmGetMessagesFromChat.mock.t.Fatalf("RepoMock.GetMessagesFromChat mock is already set by Set")
	}

	if mmGetMessagesFromChat.defaultExpectation == nil {
		mmGetMessagesFromChat.defaultExpectation = &RepoMockGetMessagesFromChatExpectation{}
	}

	if mmGetMessagesFromChat.defaultExpectation.paramPtrs != nil {
		mmGetMessagesFromChat.mock.t.Fatalf("RepoMock.GetMessagesFromChat mock is already set by ExpectParams functions")
	}

	mmGetMessagesFromChat.defaultExpectation.params = &RepoMockGetMessagesFromChatParams{chatId}
	for _, e := range mmGetMessagesFromChat.expectations {
		if minimock.Equal(e.params, mmGetMessagesFromChat.defaultExpectation.params) {
			mmGetMessagesFromChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetMessagesFromChat.defaultExpectation.params)
		}
	}

	return mmGetMessagesFromChat
}

// ExpectChatIdParam1 sets up expected param chatId for repo.GetMessagesFromChat
func (mmGetMessagesFromChat *mRepoMockGetMessagesFromChat) ExpectChatIdParam1(chatId int32) *mRepoMockGetMessagesFromChat {
	if mmGetMessagesFromChat.mock.funcGetMessagesFromChat != nil {
		mmGetMessagesFromChat.mock.t.Fatalf("RepoMock.GetMessagesFromChat mock is already set by Set")
	}

	if mmGetMessagesFromChat.defaultExpectation == nil {
		mmGetMessagesFromChat.defaultExpectation = &RepoMockGetMessagesFromChatExpectation{}
	}

	if mmGetMessagesFromChat.defaultExpectation.params != nil {
		mmGetMessagesFromChat.mock.t.Fatalf("RepoMock.GetMessagesFromChat mock is already set by Expect")
	}

	if mmGetMessagesFromChat.defaultExpectation.paramPtrs == nil {
		mmGetMessagesFromChat.defaultExpectation.paramPtrs = &RepoMockGetMessagesFromChatParamPtrs{}
	}
	mmGetMessagesFromChat.defaultExpectation.paramPtrs.chatId = &chatId

	return mmGetMessagesFromChat
}

// Inspect accepts an inspector function that has same arguments as the repo.GetMessagesFromChat
func (mmGetMessagesFromChat *mRepoMockGetMessagesFromChat) Inspect(f func(chatId int32)) *mRepoMockGetMessagesFromChat {
	if mmGetMessagesFromChat.mock.inspectFuncGetMessagesFromChat != nil {
		mmGetMessagesFromChat.mock.t.Fatalf("Inspect function is already set for RepoMock.GetMessagesFromChat")
	}

	mmGetMessagesFromChat.mock.inspectFuncGetMessagesFromChat = f

	return mmGetMessagesFromChat
}

// Return sets up results that will be returned by repo.GetMessagesFromChat
func (mmGetMessagesFromChat *mRepoMockGetMessagesFromChat) Return(mpa1 []*messageModel.Message, err error) *RepoMock {
	if mmGetMessagesFromChat.mock.funcGetMessagesFromChat != nil {
		mmGetMessagesFromChat.mock.t.Fatalf("RepoMock.GetMessagesFromChat mock is already set by Set")
	}

	if mmGetMessagesFromChat.defaultExpectation == nil {
		mmGetMessagesFromChat.defaultExpectation = &RepoMockGetMessagesFromChatExpectation{mock: mmGetMessagesFromChat.mock}
	}
	mmGetMessagesFromChat.defaultExpectation.results = &RepoMockGetMessagesFromChatResults{mpa1, err}
	return mmGetMessagesFromChat.mock
}

// Set uses given function f to mock the repo.GetMessagesFromChat method
func (mmGetMessagesFromChat *mRepoMockGetMessagesFromChat) Set(f func(chatId int32) (mpa1 []*messageModel.Message, err error)) *RepoMock {
	if mmGetMessagesFromChat.defaultExpectation != nil {
		mmGetMessagesFromChat.mock.t.Fatalf("Default expectation is already set for the repo.GetMessagesFromChat method")
	}

	if len(mmGetMessagesFromChat.expectations) > 0 {
		mmGetMessagesFromChat.mock.t.Fatalf("Some expectations are already set for the repo.GetMessagesFromChat method")
	}

	mmGetMessagesFromChat.mock.funcGetMessagesFromChat = f
	return mmGetMessagesFromChat.mock
}

// When sets expectation for the repo.GetMessagesFromChat which will trigger the result defined by the following
// Then helper
func (mmGetMessagesFromChat *mRepoMockGetMessagesFromChat) When(chatId int32) *RepoMockGetMessagesFromChatExpectation {
	if mmGetMessagesFromChat.mock.funcGetMessagesFromChat != nil {
		mmGetMessagesFromChat.mock.t.Fatalf("RepoMock.GetMessagesFromChat mock is already set by Set")
	}

	expectation := &RepoMockGetMessagesFromChatExpectation{
		mock:   mmGetMessagesFromChat.mock,
		params: &RepoMockGetMessagesFromChatParams{chatId},
	}
	mmGetMessagesFromChat.expectations = append(mmGetMessagesFromChat.expectations, expectation)
	return expectation
}

// Then sets up repo.GetMessagesFromChat return parameters for the expectation previously defined by the When method
func (e *RepoMockGetMessagesFromChatExpectation) Then(mpa1 []*messageModel.Message, err error) *RepoMock {
	e.results = &RepoMockGetMessagesFromChatResults{mpa1, err}
	return e.mock
}

// Times sets number of times repo.GetMessagesFromChat should be invoked
func (mmGetMessagesFromChat *mRepoMockGetMessagesFromChat) Times(n uint64) *mRepoMockGetMessagesFromChat {
	if n == 0 {
		mmGetMessagesFromChat.mock.t.Fatalf("Times of RepoMock.GetMessagesFromChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetMessagesFromChat.expectedInvocations, n)
	return mmGetMessagesFromChat
}

func (mmGetMessagesFromChat *mRepoMockGetMessagesFromChat) invocationsDone() bool {
	if len(mmGetMessagesFromChat.expectations) == 0 && mmGetMessagesFromChat.defaultExpectation == nil && mmGetMessagesFromChat.mock.funcGetMessagesFromChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetMessagesFromChat.mock.afterGetMessagesFromChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetMessagesFromChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetMessagesFromChat implements repo.repo
func (mmGetMessagesFromChat *RepoMock) GetMessagesFromChat(chatId int32) (mpa1 []*messageModel.Message, err error) {
	mm_atomic.AddUint64(&mmGetMessagesFromChat.beforeGetMessagesFromChatCounter, 1)
	defer mm_atomic.AddUint64(&mmGetMessagesFromChat.afterGetMessagesFromChatCounter, 1)

	if mmGetMessagesFromChat.inspectFuncGetMessagesFromChat != nil {
		mmGetMessagesFromChat.inspectFuncGetMessagesFromChat(chatId)
	}

	mm_params := RepoMockGetMessagesFromChatParams{chatId}

	// Record call args
	mmGetMessagesFromChat.GetMessagesFromChatMock.mutex.Lock()
	mmGetMessagesFromChat.GetMessagesFromChatMock.callArgs = append(mmGetMessagesFromChat.GetMessagesFromChatMock.callArgs, &mm_params)
	mmGetMessagesFromChat.GetMessagesFromChatMock.mutex.Unlock()

	for _, e := range mmGetMessagesFromChat.GetMessagesFromChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mpa1, e.results.err
		}
	}

	if mmGetMessagesFromChat.GetMessagesFromChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetMessagesFromChat.GetMessagesFromChatMock.defaultExpectation.Counter, 1)
		mm_want := mmGetMessagesFromChat.GetMessagesFromChatMock.defaultExpectation.params
		mm_want_ptrs := mmGetMessagesFromChat.GetMessagesFromChatMock.defaultExpectation.paramPtrs

		mm_got := RepoMockGetMessagesFromChatParams{chatId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.chatId != nil && !minimock.Equal(*mm_want_ptrs.chatId, mm_got.chatId) {
				mmGetMessagesFromChat.t.Errorf("RepoMock.GetMessagesFromChat got unexpected parameter chatId, want: %#v, got: %#v%s\n", *mm_want_ptrs.chatId, mm_got.chatId, minimock.Diff(*mm_want_ptrs.chatId, mm_got.chatId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetMessagesFromChat.t.Errorf("RepoMock.GetMessagesFromChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetMessagesFromChat.GetMessagesFromChatMock.defaultExpectation.results
		if mm_results == nil {
			mmGetMessagesFromChat.t.Fatal("No results are set for the RepoMock.GetMessagesFromChat")
		}
		return (*mm_results).mpa1, (*mm_results).err
	}
	if mmGetMessagesFromChat.funcGetMessagesFromChat != nil {
		return mmGetMessagesFromChat.funcGetMessagesFromChat(chatId)
	}
	mmGetMessagesFromChat.t.Fatalf("Unexpected call to RepoMock.GetMessagesFromChat. %v", chatId)
	return
}

// GetMessagesFromChatAfterCounter returns a count of finished RepoMock.GetMessagesFromChat invocations
func (mmGetMessagesFromChat *RepoMock) GetMessagesFromChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMessagesFromChat.afterGetMessagesFromChatCounter)
}

// GetMessagesFromChatBeforeCounter returns a count of RepoMock.GetMessagesFromChat invocations
func (mmGetMessagesFromChat *RepoMock) GetMessagesFromChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMessagesFromChat.beforeGetMessagesFromChatCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.GetMessagesFromChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetMessagesFromChat *mRepoMockGetMessagesFromChat) Calls() []*RepoMockGetMessagesFromChatParams {
	mmGetMessagesFromChat.mutex.RLock()

	argCopy := make([]*RepoMockGetMessagesFromChatParams, len(mmGetMessagesFromChat.callArgs))
	copy(argCopy, mmGetMessagesFromChat.callArgs)

	mmGetMessagesFromChat.mutex.RUnlock()

	return argCopy
}

// MinimockGetMessagesFromChatDone returns true if the count of the GetMessagesFromChat invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockGetMessagesFromChatDone() bool {
	if m.GetMessagesFromChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMessagesFromChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMessagesFromChatMock.invocationsDone()
}

// MinimockGetMessagesFromChatInspect logs each unmet expectation
func (m *RepoMock) MinimockGetMessagesFromChatInspect() {
	for _, e := range m.GetMessagesFromChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.GetMessagesFromChat with params: %#v", *e.params)
		}
	}

	afterGetMessagesFromChatCounter := mm_atomic.LoadUint64(&m.afterGetMessagesFromChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMessagesFromChatMock.defaultExpectation != nil && afterGetMessagesFromChatCounter < 1 {
		if m.GetMessagesFromChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.GetMessagesFromChat")
		} else {
			m.t.Errorf("Expected call to RepoMock.GetMessagesFromChat with params: %#v", *m.GetMessagesFromChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMessagesFromChat != nil && afterGetMessagesFromChatCounter < 1 {
		m.t.Error("Expected call to RepoMock.GetMessagesFromChat")
	}

	if !m.GetMessagesFromChatMock.invocationsDone() && afterGetMessagesFromChatCounter > 0 {
		m.t.Errorf("Expected %d calls to RepoMock.GetMessagesFromChat but found %d calls",
			mm_atomic.LoadUint64(&m.GetMessagesFromChatMock.expectedInvocations), afterGetMessagesFromChatCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepoMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateChatInspect()

			m.MinimockCreateChatUserInspect()

			m.MinimockCreateMessageInspect()

			m.MinimockGetChatInspect()

			m.MinimockGetMessagesFromChatInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateChatDone() &&
		m.MinimockCreateChatUserDone() &&
		m.MinimockCreateMessageDone() &&
		m.MinimockGetChatDone() &&
		m.MinimockGetMessagesFromChatDone()
}
